# ele32_lab4
ELE-32: Introdução à comunicações

Em primeiro lugar, programou-se um algoritmo em python que realizava a fatoração dos termos de D^n+1. A fatoração era reaizada por meio da divisão sucessiva do dividendo por fatores primos. Primeiramente, todos os fatores primos de grau até 8 foram encontrados e armazenados em uma lista. Para que um polinômio fosse um fator primo, ele não poderia ser divisível por nenhum outro nessa lista. Os polinômios foram armazenados na forma de uma lista de zeros e uns, e o seu incremento se dava assim como a soma de 1 em binário.


Dados os fatores primos, realizou-se uma busca, por força bruta, a todos os 2^L possíveis fatores de D^n+1. Como o código em python se mostrou muito lento para essa tarefa, programou-se o algoritmo em C. O algoritmo em C utilizou-se um conjunto de instruções do tipo SIMD projetado pela Intel, para que operações de multiplicação sem carry e peso de hamming fosse realizado em poucos ciclos de clock. Utilizou-se, para tal, registradores de 128 bits para realizar a multiplicação dos fatores. A representação dos polinômios foi feita por meio desses bits, com cada bit representando um coeficiente do polinômio. Como o processador utilizado é de 64 bits, fez-se necessário utilizar um vetor de dois elementos unsigned long long int para representar 128 bits e quatros desses para representar os 256 bits. 
Utilizou-se um inteiro de 64 bits para representar todas as possíveis combinações de até 64 fatores. Todos os 2^L possíveis fatores foram percorridos, por meio do incremento desse número, cujos bits representavam se o primo da mesma posição do bit seria ou não multiplicado. O peso de hamming desse número já era um critério de decisão inicial que descartava mais da metade de todas as combinações possíveis. Para D^127+1 o algoritmo demorou cerca de 20 milissegundos para verificar todos os fatores possíveis, já para D^255+1, o algoritmo demorou cerca de 9 minutos.


A codificação se deu pela simples multiplicação do fator g encontrado pelo vetor de informação.
O algoritmo de multiplicação, em python foi implementado como a soma, módulo 2, de um vetor com os seus deslocamentos indicados pelos bits do outro vetor. A algoritmo da divisão se deu utilizando o método da divisão euclidiana de polinômios, levando-se em consideração a soma módulo 2. Já em C, a múltiplicação era feita por uma instrução em assembly que multiplicava dois números de 64 bits e devolvia o resultado em um registrador de 128 bits "PCLMULLQLQDQ xmmreg,xmmrm", utilizando a diretiva intrínseca _mm_clmulepi64_si128. Como os fatores só tinha no máximo 64 bits, eram necessárias várias múltiplicações e deslocamentos para multiplicar fatores de 128 bits.

A decodificação se deu utilizando o algoritmo simplificado apresentado em sala. É importante notar que não necessariamente a síndrome encontrada estaria no conjunto de síndromes possíveis, mesmo após a realização de todos os giros. Para tal, verificava-se que caso fosse efetuado mais de um giro completo e não tivesse identificado nenhuma síndrome, o processo da busca das síndromes era interrompido e o quociente calculado anteriormente era utilizado como resposta.

O algoritmo simplificado apresentado em sala consistia de, em primeiro lugar, dividir o vetor recebido pelo vetor que representad o fator g. Caso o resto fosse zero, o quociente representava a palavra de informação. Caso o resto não fosse zero, ele seria a sindrome. Eram realizados giros cíclicos com a síndrome até que esta estivesse dentro do conjunto associado de síndromes conhecidas, caso no qual o valor do último bit era trocado. Dessa forma recalculava-se a síndrome e repetia-se esses passos até que o seu valor fosse zero. A quantidade de giros cíclicos era guardado, para que depois, a palavra código fosse girada ciclicamente para a posição original, podendo ser assim, dividida novamente por g, sendo o quociente a palavra de informação. É importante notar que enquanto a palavra código era girada ciclicamente em relação ao polinômio D^n+1, a síndrome era girada ciclicamente com relação ao polinômio g.

Para as instruções de assembly, escritas em C, utilizou-se cabeçalhos que encapsulavam o código de assembly emmintrin.h, wmmintrin.h, smmintrin.h e immintrin.h. As instruções utilizadas foram _mm_unpackhi_epi64, _mm_cvtsi128_si64 e _mm_store_si128para manipulaçao de 128 bits; _mm_popcnt_u64 para o cálculo do peso de hamming para uma palavra de 64 bits; _mm_clmulepi64_si128 para a multiplicação sem carry de 64 bits; _mm_xor_si128 para a soma módulo 2 de uma palavra de 128 bits; _mm_slli_si128 para o deslocamento de uma palavra de 128 bits. Essas instruções fazem parte do conjunto de intruções SSE da Intel ou 3DNow da AMD, sendo necessários um processador da 3ª geração da Intel (Ivy Bridge) ou equivalente da AMD para que o programa possa ser executado. Utilizou-se o compilador GCC versão 7.2 com as flags -save-temps -O3 -mpclmul -mavx -static -march=native habilitadas, que geram um código otimizado e utilizam as instruções citadas anteriormente. Durante este trabalho, utilizou-se um processador i7-4510U, com 8Gb de RAM disponíveis.




